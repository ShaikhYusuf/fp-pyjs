<!-- lesson4.component.html -->
<div class="lesson">
    <h1>Lesson 4: Advanced Functional Programming Concepts</h1>
  
    <section class="concept" id="monads">
      <h2>1. Monads in JavaScript and Python</h2>
      <p>A <strong>Monad</strong> is a design pattern used to handle side effects while maintaining functional purity. It allows for chaining operations without breaking functional programming principles.</p>
  
      <h3>Monads in JavaScript</h3>
      <p>JavaScript uses constructs like <strong>Promises</strong>, <strong>Maybe</strong>, and <strong>Either</strong> to implement monads.</p>
      <pre>
        <code>
          const fetchData = (url) =&gt;
            fetch(url)
              .then(response =&gt; response.json())
              .catch(error =&gt; console.log("Error:", error));
  
          fetchData("https://jsonplaceholder.typicode.com/todos/1")
            .then(data =&gt; console.log(data));
        </code>
      </pre>
  
      <h3>Monads in Python</h3>
      <p>Python doesn't have built-in monads, but we can implement similar concepts like <strong>Option</strong> (Maybe) and <strong>Result</strong> (Either).</p>
      <pre>
        <code>
          class Maybe:
              def __init__(self, value):
                  self.value = value
  
              def map(self, fn):
                  return Maybe(fn(self.value)) if self.value is not None else Maybe(None)
  
              def get_or_else(self, default):
                  return self.value if self.value is not None else default
        </code>
      </pre>
    </section>
  
    <section class="concept" id="functors">
      <h2>2. Functors and Applicative Functors</h2>
      <p>A <strong>Functor</strong> is a type that implements <code>map()</code>, allowing a function to be applied to values inside a structure.</p>
  
      <h3>Functor in JavaScript (Using Arrays)</h3>
      <pre>
        <code>
          const numbers = [1, 2, 3];
          const doubled = numbers.map(x =&gt; x * 2);
          console.log(doubled); // Output: [2, 4, 6]
        </code>
      </pre>
  
      <h3>Functor in Python (Using map())</h3>
      <pre>
        <code>
          numbers = [1, 2, 3]
          doubled = list(map(lambda x: x * 2, numbers))
          print(doubled)  # Output: [2, 4, 6]
        </code>
      </pre>
  
      <h3>Applicative Functors in JavaScript</h3>
      <pre>
        <code>
          const add = (a) =&gt; (b) =&gt; a + b;
          const addThree = [add(3)];
          console.log(addThree.map(fn =&gt; fn(5))); // Output: [8]
        </code>
      </pre>
    </section>
  
    <section class="concept" id="error-handling">
      <h2>3. Functional Error Handling</h2>
      <p>Error handling in functional programming can be tricky, but with monads like <strong>Either</strong> and <strong>Result</strong>, we can handle errors more functionally and safely.</p>
  
      <h3>Either Monad (Safe Error Handling) in JavaScript</h3>
      <pre>
        <code>
          const Either = {{'{'}}
            right: (value) =&gt; ({{'{'}} isRight: true, map: (fn) =&gt; Either.right(fn(value)), get: () =&gt; value {{'}'}}),
            left: (error) =&gt; ({{'{'}} isRight: false, map: () =&gt; Either.left(error), get: () =&gt; error {{'}'}})
          {{'}'}};
  
          const divide = (a, b) =&gt; (b === 0 ? Either.left("Cannot divide by zero") : Either.right(a / b));
  
          console.log(divide(10, 2).get());  // Output: 5
          console.log(divide(10, 0).get());  // Output: "Cannot divide by zero"
        </code>
      </pre>
  
      <h3>Result Type in Python</h3>
      <pre>
        <code>
          class Result:
              def __init__(self, value, is_error=False):
                  self.value = value
                  self.is_error = is_error
  
              def map(self, fn):
                  return Result(fn(self.value)) if not self.is_error else self
  
              def get(self):
                  return self.value
  
          def divide(a, b):
              return Result("Cannot divide by zero", True) if b == 0 else Result(a / b)
  
          print(divide(10, 2).get())  # Output: 5
          print(divide(10, 0).get())  # Output: Cannot divide by zero
        </code>
      </pre>
    </section>
  
    <section class="concept" id="concurrency">
      <h2>4. Concurrency and Parallelism in FP</h2>
      <h3>Concurrency with JavaScript async/await</h3>
      <pre>
        <code>
          async function fetchData() {{'{'}}
              const response = await fetch("https://jsonplaceholder.typicode.com/todos/1");
              const data = await response.json();
              console.log(data);
          {{'}'}}
  
          fetchData();
        </code>
      </pre>
  
      <h3>Pythonâ€™s asyncio</h3>
      <pre>
        <code>
          import asyncio
  
          async def fetch_data():
              print("Fetching data...")
              await asyncio.sleep(2)  # Simulate delay
              print("Data fetched!")
  
          asyncio.run(fetch_data())
        </code>
      </pre>
    </section>
  
    <section class="concept" id="immutable">
      <h2>5. Purely Functional Data Structures</h2>
      <p>Immutable data structures prevent modifying existing values, ensuring functional purity.</p>
  
      <h3>Immutable.js (JavaScript)</h3>
      <pre>
        <code>
          const {{'{'}} Map {{'}'}} = require("immutable");
  
          const obj = Map({{'{'}} name: "Alice", age: 25 {{'}'}});
          const updatedObj = obj.set("age", 26);
  
          console.log(obj.get("age")); // Output: 25
          console.log(updatedObj.get("age")); // Output: 26
        </code>
      </pre>
  
      <h3>Immutable Data in Python</h3>
      <pre>
        <code>
          from frozendict import frozendict
  
          person = frozendict({{'{'}}"name": "Alice", "age": 25{{'}'}})
          new_person = person.copy().update({{'{'}}"age": 26{{'}'}})  # Returns a new frozendict
  
          print(person["age"])  # Output: 25
          print(new_person["age"])  # Output: 26
        </code>
      </pre>
    </section>
  
    <section class="conclusion">
      <h2>Conclusion</h2>
      <ul>
        <li><strong>Monads</strong> simplify error handling and async operations by abstracting side effects.</li>
        <li><strong>Functors</strong> allow you to map over values inside a structure, making it easier to apply functions.</li>
        <li><strong>Error Handling</strong> ensures safe computation without crashes by using containers like Either and Result.</li>
        <li><strong>Concurrency</strong> techniques help optimize asynchronous tasks in functional programming.</li>
        <li><strong>Immutable Data</strong> structures preserve purity and avoid side effects by preventing mutation.</li>
      </ul>
    </section>
  </div>
  