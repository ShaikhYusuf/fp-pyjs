<!-- app.component.html -->

<div class="container">
  <h1>Lesson 1: Introduction to Functional Programming (FP)</h1>

  <!-- 1. What is Functional Programming? -->
  <section id="what-is-fp">
    <h2>1. What is Functional Programming?</h2>
    <p>
      Functional Programming (FP) is a programming paradigm where programs are constructed by applying and composing <strong>functions</strong>. Unlike imperative programming, which focuses on <strong>how to do things</strong> (step-by-step instructions), FP focuses on <strong>what to do</strong> by expressing logic as mathematical functions.
    </p>

    <h3>Key Characteristics of FP:</h3>
    <ul>
      <li><strong>Puer Functions:</strong> Functions that always produce the same output for the same input and have no side effects.</li>
      <li><strong>Immutability:</strong> Data is never modified after it’s created.</li>
      <li><strong>First-Class and Higher-Order Functions:</strong> Functions are treated as values and can be passed as arguments or returned from other functions.</li>
      <li><strong>Declarative Style:</strong> Code describes what should happen, not how it should happen.</li>
    </ul>
  </section>

  <!-- 2. Functional Programming Principles and Advantages -->
  <section id="principles-advantages">
    <h2>2. Functional Programming Principles and Advantages</h2>

    <h3>Principles of FP:</h3>
    <ol>
      <li><strong>Pure Functions:</strong> Avoid side effects and rely only on inputs to produce outputs.</li>
      <li><strong>Immutability:</strong> Data is never changed; instead, new data is created.</li>
      <li><strong>Function Composition:</strong> Combining simple functions to build complex ones.</li>
      <li><strong>Declarative Code:</strong> Focus on the "what" rather than the "how."</li>
    </ol>

    <h3>Advantages of FP:</h3>
    <ul>
      <li><strong>Predictability:</strong> Pure functions and immutability make code easier to reason about.</li>
      <li><strong>Concurrency:</strong> Immutable data structures are inherently thread-safe.</li>
      <li><strong>Reusability:</strong> Small, pure functions can be reused across the codebase.</li>
      <li><strong>Debugging:</strong> Fewer side effects mean fewer bugs.</li>
    </ul>
  </section>

  <!-- 3. Comparing Functional Programming with Imperative and Object-Oriented Programming -->
  <section id="comparison">
    <h2>3. Comparing Functional Programming with Imperative and Object-Oriented Programming</h2>

    <h3>Imperative Programming:</h3>
    <p>
      Imperative programming focuses on <strong>how to do things</strong> using statements that change the program’s state. It works with loops and conditional structures.
    </p>

    <div class="code-block">
      <pre>
        <code>
        // JavaScript: Imperative
        let numbers = [1, 2, 3];
        for (let i = 0; i < numbers.length; i++) {{'{'}}
          numbers[i] = numbers[i] * 2;
        {{'}'}}
        console.log(numbers); // Output: [2, 4, 6]
        </code>
      </pre>
    </div>

    <h3>Object-Oriented Programming (OOP):</h3>
    <p>
      Object-Oriented Programming focuses on <strong>objects</strong> and <strong>methods</strong> that operate on data.
    </p>

    <div class="code-block">
      <pre>
        <code>
        // JavaScript: OOP
        class Calculator {{'{'}}
          add(a, b) {{'{'}}
            return a + b;
          {{'}'}}
        {{'}'}}
        const calc = new Calculator();
        console.log(calc.add(2, 3)); // Output: 5
        </code>
      </pre>
    </div>

    <h3>Functional Programming:</h3>
    <p>
      Functional programming focuses on <strong>what to do</strong> using pure functions and immutable data.
    </p>

    <div class="code-block">
      <pre>
        <code>
        // JavaScript: Functional
        const numbers = [1, 2, 3];
        const doubled = numbers.map(x => x * 2);
        console.log(doubled); // Output: [2, 4, 6]
        </code>
      </pre>
    </div>
  </section>

  <!-- 4. Functional Programming Paradigms -->
  <section id="paradigms">
    <h2>4. Functional Programming Paradigms</h2>

    <h3>Pure Functions and Side Effects</h3>
    <p>
      A <strong>pure function</strong> always produces the same output for the same input and has no side effects (e.g., modifying global state or I/O operations).
    </p>

    <div class="code-block">
      <pre>
        <code>
        // JavaScript: Pure Function
        const add = (a, b) => a + b;
        console.log(add(2, 3)); // Output: 5
        </code>
      </pre>
    </div>

    <h3>First-Class Functions</h3>
    <p>
      Functions are treated as <strong>first-class citizens</strong>, meaning they can be assigned to variables, passed as arguments, and returned from other functions.
    </p>

    <div class="code-block">
      <pre>
        <code>
        // JavaScript: First-Class Function
        const greet = () => "Hello, World!";
        console.log(greet()); // Output: Hello, World!
        </code>
      </pre>
    </div>

    <h3>Higher-Order Functions</h3>
    <p>
      A <strong>higher-order function</strong> is a function that takes another function as an argument or returns a function.
    </p>

    <div class="code-block">
      <pre>
        <code>
        // JavaScript: Higher-Order Function
        const twice = (f, x) => f(f(x));
        const addOne = x => x + 1;
        console.log(twice(addOne, 5)); // Output: 7
        </code>
      </pre>
    </div>

    <h3>Immutability</h3>
    <p>
      Data is never modified; instead, new data is created.
    </p>

    <div class="code-block">
      <pre>
        <code>
        // JavaScript: Immutability
        const numbers = [1, 2, 3];
        const newNumbers = [...numbers, 4]; // Create a new array
        console.log(newNumbers); // Output: [1, 2, 3, 4]
        </code>
      </pre>
    </div>

    <h3>Referential Transparency</h3>
    <p>
      An expression is <strong>referentially transparent</strong> if it can be replaced with its value without changing the program’s behavior.
    </p>

    <div class="code-block">
      <pre>
        <code>
        // JavaScript: Referential Transparency
        const add = (a, b) => a + b;
        console.log(add(2, 3) === 5); // Output: true
        </code>
      </pre>
    </div>
  </section>

  <!-- 5. FP in JavaScript vs Python -->
  <section id="fp-in-javascript-vs-python">
    <h2>5. FP in JavaScript vs Python</h2>

    <h3>JavaScript's Support for FP:</h3>
    <p>JavaScript supports FP features like first-class functions, closures, and arrow functions.</p>

    <div class="code-block">
      <pre>
        <code>
        // JavaScript: Arrow Function
        const square = x => x * x;
        console.log(square(5)); // Output: 25
        </code>
      </pre>
    </div>

    <h3>Python's Support for FP:</h3>
    <p>Python supports FP with features like lambdas, map, filter, and functools.</p>

    <div class="code-block">
      <pre>
        <code>
        // Python: Lambda and map
        numbers = [1, 2, 3]
        squared = list(map(lambda x: x * x, numbers))
        print(squared)  # Output: [1, 4, 9]
        </code>
      </pre>
    </div>
  </section>

  <!-- Summary -->
  <section id="summary">
    <h2>Summary</h2>
    <p>Functional Programming focuses on <strong>pure functions</strong>, <strong>immutability</strong>, and <strong>declarative code</strong>.</p>
    <p>It contrasts with imperative and object-oriented programming by emphasizing <strong>what to do</strong> rather than <strong>how to do it</strong>.</p>
    <p>JavaScript and Python both support FP with features like <strong>first-class functions</strong>, <strong>higher-order functions</strong>, and <strong>immutability</strong>.</p>
  </section>
</div>
