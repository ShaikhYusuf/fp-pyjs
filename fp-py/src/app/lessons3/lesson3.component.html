<div class="lesson">
    <h1>Lesson 3: Intermediate Functional Programming Concepts</h1>
  
    <!-- Pattern Matching Section -->
    <section id="pattern-matching">
      <h2>1. Pattern Matching</h2>
  
      <h3>What is Pattern Matching?</h3>
      <p>Pattern matching is a way to check a value against a pattern and extract data from it. It’s a powerful feature for working with complex data structures.</p>
  
      <h4>Pattern Matching in JavaScript</h4>
      <h5>1. Destructuring</h5>
      <pre><code>const [a, b] = [1, 2];
  console.log(a, b); // Output: 1 2
  
  const {{'{'}} name, age {{'}'}} = {{'{'}} name: "Alice", age: 25 {{'}'}};
  console.log(name, age); // Output: Alice 25</code></pre>
      <p><strong>Explanation:</strong> Destructuring allows you to unpack values from arrays or properties from objects into distinct variables.</p>
  
      <h5>2. Switch-Case</h5>
      <pre><code>const getDayType = (day) => {{'{'}}
    switch (day) {{'{'}}
      case "Monday":
      case "Tuesday":
        return "Weekday";
      case "Saturday":
      case "Sunday":
        return "Weekend";
      default:
        return "Invalid day";
    {{'}'}}
  {{'}'}};
  
  console.log(getDayType("Monday")); // Output: Weekday</code></pre>
      <p><strong>Explanation:</strong> The <code>switch-case</code> statement matches the value of <code>day</code> and returns the corresponding result.</p>
  
      <h4>Pattern Matching in Python</h4>
      <h5>1. Match Statement (Python 3.10+)</h5>
      <pre><code>def get_day_type(day):
      match day:
          case "Monday" | "Tuesday":
              return "Weekday"
          case "Saturday" | "Sunday":
              return "Weekend"
          case _:
              return "Invalid day"
  
  print(get_day_type("Monday"))  # Output: Weekday</code></pre>
      <p><strong>Explanation:</strong> The <code>match</code> statement matches the value of <code>day</code> and returns the corresponding result.</p>
    </section>
  
    <!-- Recursion Section -->
    <section id="recursion">
      <h2>2. Recursion</h2>
      <h3>What is Recursion?</h3>
      <p>Recursion is a technique where a function calls itself to solve a problem. It’s commonly used for tasks like traversing trees or calculating Fibonacci numbers.</p>
  
      <h4>Recursion in JavaScript</h4>
      <h5>1. Fibonacci Sequence</h5>
      <pre><code>const fibonacci = (n) => {{'{'}}
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
  {{'}'}};
  
  console.log(fibonacci(6)); // Output: 8</code></pre>
      <p><strong>Explanation:</strong> The <code>fibonacci</code> function calls itself to calculate the Fibonacci sequence.</p>
  
      <h5>2. Tree Traversal</h5>
      <pre><code>const tree = {{'{'}}
    value: 1,
    left: {{'{'}} value: 2, left: null, right: null {{'}'}},
    right: {{'{'}} value: 3, left: null, right: null {{'}'}},
  {{'}'}};
  
  const traverse = (node) => {{'{'}}
    if (!node) return;
    console.log(node.value); // Visit the node
    traverse(node.left); // Traverse left subtree
    traverse(node.right); // Traverse right subtree
  {{'}'}};
  
  traverse(tree); // Output: 1 2 3</code></pre>
      <p><strong>Explanation:</strong> The <code>traverse</code> function recursively visits each node in the tree.</p>
  
      <h4>Recursion in Python</h4>
      <h5>1. Fibonacci Sequence</h5>
      <pre><code>def fibonacci(n):
      if n <= 1:
          return n
      return fibonacci(n - 1) + fibonacci(n - 2)
  
  print(fibonacci(6))  # Output: 8</code></pre>
      <p><strong>Explanation:</strong> The <code>fibonacci</code> function calls itself to calculate the Fibonacci sequence.</p>
  
      <h5>2. Tree Traversal</h5>
      <pre><code>tree = {{'{'}}
      "value": 1,
      "left": {{'{'}}"value": 2, "left": None, "right": None{{'}'}},
      "right": {{'{'}}"value": 3, "left": None, "right": None{{'}'}},
  {{'}'}}
  
  def traverse(node):
      if not node:
          return
      print(node["value"])  # Visit the node
      traverse(node["left"])  # Traverse left subtree
      traverse(node["right"])  # Traverse right subtree
  
  traverse(tree)  # Output: 1 2 3</code></pre>
      <p><strong>Explanation:</strong> The <code>traverse</code> function recursively visits each node in the tree.</p>
  
      <h4>Tail Recursion and Optimization</h4>
      <h5>JavaScript Example: Tail Recursion</h5>
      <pre><code>const factorial = (n, acc = 1) => {{'{'}}
    if (n <= 1) return acc;
    return factorial(n - 1, n * acc); // Tail-recursive call
  {{'}'}};
  
  console.log(factorial(5)); // Output: 120</code></pre>
      <p><strong>Explanation:</strong> The <code>factorial</code> function uses tail recursion to calculate the factorial of a number.</p>
  
      <h5>Python Example: Tail Recursion</h5>
      <pre><code>def factorial(n, acc=1):
      if n <= 1:
          return acc
      return factorial(n - 1, n * acc)  # Tail-recursive call
  
  print(factorial(5))  # Output: 120</code></pre>
      <p><strong>Explanation:</strong> The <code>factorial</code> function uses tail recursion, but Python does not optimize it.</p>
    </section>
  
    <!-- Lazy Evaluation Section -->
    <section id="lazy-evaluation">
      <h2>3. Lazy Evaluation</h2>
      <h3>What is Lazy Evaluation?</h3>
      <p>Lazy evaluation is a technique where expressions are not evaluated until their results are needed. This is useful for working with infinite sequences or large datasets.</p>
  
      <h4>Lazy Evaluation in JavaScript</h4>
      <h5>1. Generators</h5>
      <pre><code>function* fibonacciSequence() {{'{'}}
    let [a, b] = [0, 1];
    while (true) {{'{'}}
      yield a;
      [a, b] = [b, a + b];
    {{'}'}}
  {{'}'}}
  
  const fib = fibonacciSequence();
  console.log(fib.next().value); // Output: 0
  console.log(fib.next().value); // Output: 1
  console.log(fib.next().value); // Output: 1</code></pre>
      <p><strong>Explanation:</strong> The <code>fibonacciSequence</code> generator lazily produces Fibonacci numbers.</p>
  
      <h4>Lazy Evaluation in Python</h4>
      <h5>1. Generators</h5>
      <pre><code>def fibonacci_sequence():
      a, b = 0, 1
      while True:
          yield a
          a, b = b, a + b
  
  fib = fibonacci_sequence()
  print(next(fib))  # Output: 0
  print(next(fib))  # Output: 1
  print(next(fib))  # Output: 1</code></pre>
      <p><strong>Explanation:</strong> The <code>fibonacci_sequence</code> generator lazily produces Fibonacci numbers.</p>
    </section>
  
    <!-- Type Systems Section -->
    <section id="type-systems">
      <h2>4. Type Systems in FP</h2>
  
      <h4>JavaScript's Weak Typing and Type Inference</h4>
      <p>JavaScript is dynamically typed, but tools like <strong>TypeScript</strong> add type safety.</p>
  
      <h5>TypeScript Example</h5>
      <pre><code>const add = (a: number, b: number): number => a + b;
  console.log(add(2, 3)); // Output: 5</code></pre>
      <p><strong>Explanation:</strong> TypeScript adds type annotations to ensure <code>a</code> and <code>b</code> are numbers.</p>
  
      <h4>Python’s Dynamic Typing and Optional Type Annotations</h4>
      <p>Python is dynamically typed but supports optional type annotations.</p>
  
      <h5>Python Example</h5>
      <pre><code>def add(a: int, b: int) -> int:
      return a + b
  
  print(add(2, 3))  # Output: 5</code></pre>
      <p><strong>Explanation:</strong> Python’s type annotations are optional but improve code readability and tooling support.</p>
    </section>
  
    <!-- Currying and Partial Application Section -->
    <section id="currying">
      <h2>5. Currying and Partial Application</h2>
  
      <h3>What is Currying?</h3>
      <p>Currying is the process of transforming a function that takes multiple arguments into a sequence of functions that each take a single argument.</p>
  
      <h3>What is Partial Application?</h3>
      <p>Partial application is the process of fixing a number of arguments to a function, producing a new function with fewer arguments.</p>
  
      <h4>Currying in JavaScript</h4>
      <h5>1. Using Closures</h5>
      <pre><code>const add = (a) => (b) => a + b;
  const addFive = add(5);
  console.log(addFive(3)); // Output: 8</code></pre>
      <p><strong>Explanation:</strong> The <code>add</code> function is curried, and <code>addFive</code> partially applies the first argument.</p>
  
      <h4>Partial Application in Python</h4>
      <h5>1. Using <code>functools.partial</code></h5>
      <pre><code>from functools import partial
  
  def add(a, b):
      return a + b
  
  add_five = partial(add, 5)
  print(add_five(3))  # Output: 8</code></pre>
      <p><strong>Explanation:</strong> <code>functools.partial</code> creates a new function with the first argument fixed.</p>
    </section>
  
    <!-- Summary Section -->
    <section id="summary">
      <h2>Summary</h2>
      <ul>
        <li><strong>Pattern matching:</strong> simplifies working with complex data structures.</li>
        <li><strong>Recursion:</strong> is a powerful technique for solving problems like tree traversal.</li>
        <li><strong>Lazy evaluation:</strong> delays computation until needed, useful for infinite sequences.</li>
        <li><strong>Type systems:</strong> in JavaScript and Python provide flexibility and safety.</li>
        <li><strong>Currying and partial application:</strong> enable flexible function composition.</li>
      </ul>
    </section>
  </div>
  